{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-225194e0892443818cfc26b17a76a999a5e70850",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/BloxlandENS.sol": "project/contracts/BloxlandENS.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/IERC1155Receiver.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity >=0.6.2;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface that must be implemented by smart contracts in order to receive\n * ERC-1155 token transfers.\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC-1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC-1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC1155/utils/ERC1155Holder.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165, ERC165} from \"../../../utils/introspection/ERC165.sol\";\nimport {IERC1155Receiver} from \"../IERC1155Receiver.sol\";\n\n/**\n * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC-1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n */\nabstract contract ERC1155Holder is ERC165, IERC1155Receiver {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/ERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /// @inheritdoc IERC165\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/introspection/IERC165.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
      },
      "project/contracts/BloxlandENS.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport {ERC1155Holder} from \"@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol\";\n\ninterface INameWrapper {\n    function setSubnodeOwner(\n        bytes32 parentNode,\n        string calldata label,\n        address owner,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 parentNode,\n        string calldata label,\n        address owner,\n        address resolver,\n        uint64 ttl,\n        uint32 fuses,\n        uint64 expiry\n    ) external;\n}\n\ncontract BloxlandSubnameRegistrar is ERC1155Holder {\n    INameWrapper public nameWrapper;\n    address public resolver;\n    address public owner;\n    bytes32 public parentNode;\n    uint32 public defaultFuses;\n    uint64 public defaultExpiry;\n\n    event SubnameRegistered(\n        address indexed subdomainOwner,\n        string label,\n        bytes32 indexed node,\n        uint64 expiry\n    );\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call\");\n        _;\n    }\n\n    constructor(\n        address _nameWrapper,\n        address _resolver,\n        bytes32 _parentNode,\n        uint32 _defaultFuses,\n        uint64 _defaultExpiry\n    ) {\n        nameWrapper = INameWrapper(_nameWrapper);\n        resolver = _resolver;\n        owner = msg.sender;\n        parentNode = _parentNode;\n        defaultFuses = _defaultFuses;\n        defaultExpiry = _defaultExpiry;\n    }\n\n    function registerSubname(string calldata label, address userAddress) external {\n        require(userAddress != address(0), \"Invalid address\");\n        require(_isValidLabel(label), \"Invalid label format\");\n        _registerSubname(label, userAddress);\n    }\n\n    function _registerSubname(string calldata label, address subdomainOwner) internal {\n        nameWrapper.setSubnodeOwner(parentNode, label, address(this), defaultFuses, defaultExpiry);\n        \n        // Fixed: Use correct domain name in namehash\n        bytes32 node = namehash(string(abi.encodePacked(label, \".blockxland.eth\")));\n\n\n        nameWrapper.setSubnodeRecord(\n            parentNode,\n            label,\n            subdomainOwner,\n            resolver,\n            0,\n            defaultFuses,\n            defaultExpiry\n        );\n\n        emit SubnameRegistered(subdomainOwner, label, node, defaultExpiry);\n    }\n\n    function namehash(string memory _name) public pure returns (bytes32 node) {\n        node = 0x0;\n        string[] memory labels = split(_name, \".\");\n        for (uint i = labels.length; i > 0; i--) {\n            node = keccak256(abi.encodePacked(node, keccak256(bytes(labels[i - 1]))));\n        }\n    }\n\n    function split(string memory _base, string memory _sep) internal pure returns (string[] memory parts) {\n        bytes memory baseBytes = bytes(_base);\n        bytes1 sepByte = bytes(_sep)[0];\n        uint count = 1;\n        \n        for (uint i = 0; i < baseBytes.length; i++) {\n            if (baseBytes[i] == sepByte) count++;\n        }\n\n        parts = new string[](count);\n        uint partIndex = 0;\n        bytes memory buffer;\n\n        for (uint i = 0; i < baseBytes.length; i++) {\n            if (baseBytes[i] != sepByte) {\n                buffer = abi.encodePacked(buffer, baseBytes[i]);\n            } else {\n                parts[partIndex++] = string(buffer);\n                buffer = \"\";\n            }\n        }\n\n        parts[partIndex] = string(buffer);\n    }\n\n    function updateDefaults(uint32 _fuses, uint64 _expiry) external onlyOwner {\n        defaultFuses = _fuses;\n        defaultExpiry = _expiry;\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid owner\");\n        owner = newOwner;\n    }\n\n    function recoverSubname(string calldata label) external onlyOwner {\n        nameWrapper.setSubnodeOwner(parentNode, label, owner, defaultFuses, defaultExpiry);\n    }\n\n    function getNodeHash(string calldata label) external pure returns (bytes32) {\n    return namehash(string(abi.encodePacked(label, \".blockxland.eth\")));\n}\n\n    function isValidLabel(string calldata label) external pure returns (bool) {\n        return _isValidLabel(label);\n    }\n\n    function _isValidLabel(string memory label) internal pure returns (bool) {\n        bytes memory labelBytes = bytes(label);\n        \n        if (labelBytes.length == 0 || labelBytes.length > 63) return false;\n        if (labelBytes[0] == 0x2d || labelBytes[labelBytes.length - 1] == 0x2d) return false;\n\n        for (uint i = 0; i < labelBytes.length; i++) {\n            bytes1 char = labelBytes[i];\n            if (!(\n                (char >= 0x61 && char <= 0x7a) || \n                (char >= 0x41 && char <= 0x5a) || \n                (char >= 0x30 && char <= 0x39) || \n                char == 0x2d\n            )) return false;\n        }\n        return true;\n    }\n}"
      }
    }
  }
}